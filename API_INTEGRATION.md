
# Документация по интеграциям с внешними API

## Архитектура работы с API ключами

### Хранение ключей
- Все API ключи хранятся в базе данных Directus (таблица `user_api_keys`)
- Структура таблицы:
  - `id`: UUID
  - `user_id`: ID пользователя
  - `service_name`: Название сервиса
  - `api_key`: Значение ключа

### Сервисы и их особенности

1. **FAL.AI** (генерация изображений)
- Формат ключа: `key:secret` 
- Особенность: При сохранении удаляется префикс "Key ", при использовании добавляется
- Валидация: Проверяется наличие ":" в ключе

2. **DeepSeek** (генерация текста)
- Стандартный API ключ
- Используется для анализа и генерации структурированного контента

3. **Perplexity** (поиск контента)
- Стандартный API ключ
- Используется для поиска и анализа релевантного контента

4. **XMLRiver** (Яндекс.Вордстат)
- Формат: JSON с user_id и api_key
- Особенность: Автоматическое форматирование в JSON при сохранении

## Основные проблемы и решения

### 1. Проблема с форматом ключей FAL.AI
**Проблема:** Неконсистентный формат хранения (с/без префикса "Key ")
**Решение:** 
- Хранение без префикса в БД
- Добавление префикса при вызове API
- Валидация формата при сохранении

### 2. Кэширование токенов и ключей
**Проблема:** Частые запросы к БД за ключами
**Решение:**
- Реализован кэш с временем жизни 30 минут
- Автоматическая очистка устаревших записей
- Инвалидация кэша при обновлении ключей

### 3. Безопасность и доступ
**Проблема:** Разграничение доступа к API ключам
**Решение:**
- Привязка ключей к конкретным пользователям
- Проверка владельца при каждом запросе
- Шифрование ключей в БД

## Приоритизация API ключей

1. Пользовательские ключи имеют высший приоритет
2. Системные ключи используются как fallback
3. Ключи из .env не используются в production

## Процесс обработки API запросов

1. Получение ключа из кэша/БД
2. Валидация и форматирование ключа
3. Выполнение запроса через соответствующий сервис
4. Обработка ошибок и повторные попытки

## Рекомендации по развитию

1. Реализовать мониторинг использования API
2. Добавить квоты на использование
3. Внедрить систему ротации ключей
4. Улучшить обработку ошибок специфичных для каждого API
