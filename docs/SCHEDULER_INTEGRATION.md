# Интеграция планировщика публикаций

Данный документ описывает архитектуру и принципы работы планировщика публикаций контента в социальных сетях.

## Архитектура

Планировщик публикаций интегрирован с системой публикации контента и использует **тот же код**, что и моментальная публикация. Это гарантирует единообразное поведение, независимо от способа публикации.

```
API (publishing-routes.ts)
    │
    ├─ Моментальная публикация ──┐ 
    │                             │
    │                             ▼
    │                   SocialPublishingService
    │                       (social/index.ts)
    │                             │
    │                             ├─ TelegramService
    │                             ├─ VkService
    │                             └─ InstagramService
    │
    └─ Планировщик публикаций
        (publish-scheduler.ts)  ──┘
```

## Процесс планирования публикации

1. Контент сохраняется в базе данных со статусом `scheduled` и указанием времени публикации в поле `scheduledAt`
2. Планировщик запускается с заданным интервалом (по умолчанию: каждую минуту)
3. На каждой итерации планировщик:
   - Авторизуется в Directus API для получения доступа к контенту
   - Запрашивает контент со статусом `scheduled`
   - Отбирает публикации, для которых наступило время публикации
   - Для каждой отобранной публикации вызывает метод `publishToPlatform()` сервиса `SocialPublishingService`

## Алгоритм работы

```javascript
async function checkScheduledPublications() {
  // Получение токена для авторизации API запросов
  const adminToken = await getAdminToken();
  
  // Получение запланированных публикаций
  const scheduledPublications = await getScheduledPublications(adminToken);
  
  // Фильтрация публикаций, время которых наступило
  const readyToPublish = scheduledPublications.filter(
    pub => new Date(pub.scheduledAt) <= new Date()
  );
  
  // Публикация каждого готового поста
  for (const content of readyToPublish) {
    try {
      // Непосредственно публикация через тот же сервис, что и для моментальных публикаций
      await socialPublishingService.publishToPlatform(content);
    } catch (error) {
      // Обработка ошибок
      log(`Ошибка при публикации запланированного контента: ${error.message}`);
    }
  }
}
```

## Преимущества прямой интеграции

1. **Единый код для всех типов публикаций** - снижает риск расхождений в логике между моментальной и запланированной публикацией
2. **Отсутствие внутренних HTTP запросов** - повышает эффективность и снижает нагрузку на сервер
3. **Улучшенная отладка** - проще отслеживать весь процесс публикации от начала до конца

## Обработка ошибок

В случае ошибки при публикации контента планировщиком:

1. Ошибка логируется в систему логирования
2. Статус публикации обновляется в поле `socialPlatforms`
3. При критической ошибке статус контента может быть изменен на `failed`
4. Система продолжает работу с другими запланированными публикациями

## Мониторинг и отладка

Для отслеживания работы планировщика:

1. Логи в консоли с тегом `[scheduler]`
2. Детальные записи в логах планировщика и сервисов публикации
3. API эндпоинт `/api/publish/scheduled` для получения списка запланированных публикаций

## Конфигурация

Настройка планировщика осуществляется в `server/config/scheduler.ts`:

```javascript
const SCHEDULER_CONFIG = {
  // Интервал проверки публикаций (в миллисекундах)
  checkInterval: 60000, // 1 минута
  
  // Количество одновременных публикаций
  maxConcurrentPublications: 3,
  
  // Максимальное количество попыток публикации
  maxRetries: 3
};
```

## Запуск и остановка

Планировщик запускается автоматически при старте сервера:

```javascript
// Инициализация планировщика
export const publishScheduler = new PublishScheduler();

// Запуск планировщика
publishScheduler.start();

// Остановка планировщика (при необходимости)
// publishScheduler.stop();
```