{
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "ae581e17-651d-4b14-8fb1-ca16898bca1b",
        "options": {}
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 2,
      "position": [
        0,
        0
      ],
      "id": "0d8ed220-b9b5-4102-afbe-f0d3c2b322c9",
      "name": "Webhook",
      "webhookId": "ae581e17-651d-4b14-8fb1-ca16898bca1b"
    },
    {
      "parameters": {
        "jsCode": "const inputData = $input.first();\nconst campaignId = inputData.data.campaignId;\nconst userId = inputData.data.userId;\nconst settings = inputData.data.settings;\nconst trends = inputData.data.trends || [];\nconst keywords = inputData.data.keywords || [];\nconst businessData = inputData.data.businessData;\nconst directusToken = inputData.data.directusToken;\n\n// Формируем промпт для генерации контента\nconst businessInfo = businessData ? `\nИнформация о бизнесе:\n- Название компании: ${businessData.companyName}\n- Описание бизнеса: ${businessData.businessDescription}\n- Основная аудитория: ${businessData.targetAudience}\n- Ценности бренда: ${businessData.businessValues || ''}\n- Продукты и услуги: ${businessData.productsServices}\n- Конкурентные преимущества: ${businessData.competitiveAdvantages || ''}\n` : 'Информация о бизнесе отсутствует.';\n\nconst keywordsText = keywords.length > 0 \n  ? `Ключевые слова для кампании: ${keywords.map(k => k.keyword).join(', ')}`\n  : 'Ключевые слова отсутствуют.';\n\nconst trendsText = trends.length > 0\n  ? `Выбранные тренды:\n${trends.map(trend => `- ${trend.title} (Реакции: ${trend.reactions}, Комментарии: ${trend.comments}, Просмотры: ${trend.views})`).join('\\n')}`\n  : 'Тренды не выбраны.';\n\nconst contentTypeTranslation = {\n  'mixed': 'смешанный',\n  'educational': 'обучающий',\n  'promotional': 'рекламный',\n  'entertaining': 'развлекательный',\n  'text': 'только текст',\n  'text-image': 'текст с изображениями',\n  'video': 'с видео'\n};\n\nconst contentTypeText = settings.contentType \n  ? `Тип контента: ${contentTypeTranslation[settings.contentType] || settings.contentType}`\n  : 'Тип контента: смешанный';\n\nconst mediaTypeText = `Типы медиа: ${settings.includeImages ? 'изображения' : ''}${settings.includeImages && settings.includeVideos ? ' и ' : ''}${settings.includeVideos ? 'видео' : ''}`;\n\n// Создаем массив дат равномерно распределенных в периоде\nconst now = new Date();\nconst endDate = new Date(now);\nendDate.setDate(endDate.getDate() + settings.period);\n\nconst dates = [];\nconst dateInterval = settings.period / settings.postsCount;\n\nfor (let i = 0; i < settings.postsCount; i++) {\n  const postDate = new Date(now);\n  postDate.setDate(postDate.getDate() + Math.round(i * dateInterval));\n  // Устанавливаем случайное время дня между 9:00 и 20:00\n  postDate.setHours(9 + Math.floor(Math.random() * 11), Math.floor(Math.random() * 60));\n  dates.push(postDate);\n}\n\n// Сортируем даты\ndates.sort((a, b) => a.getTime() - b.getTime());\n\n// Форматируем даты для включения в промпт\nconst datesText = `Даты публикаций:\n${dates.map((date, index) => `${index + 1}. ${date.toLocaleDateString('ru-RU')} ${date.toLocaleTimeString('ru-RU', { hour: '2-digit', minute: '2-digit' })}`).join('\\n')}`;\n\n// Формируем промпт для генерации контент-плана\nconst prompt = `Создай детальный контент-план для социальных сетей на ${settings.period} дней с ${settings.postsCount} постами. \n\n${businessInfo}\n\n${keywordsText}\n\n${trendsText}\n\n${contentTypeText}\n${mediaTypeText}\n\n${datesText}\n\n${settings.customInstructions ? 'Дополнительные инструкции: ' + settings.customInstructions : ''}\n\nДля каждой даты создай пост со следующей структурой:\n1. Заголовок\n2. Текст поста (HTML-форматирование)\n3. Тип контента (text, text-image, video, video-text)\n4. Хештеги (до 5-7 релевантных)\n5. Ключевые слова (3-5 слов)\n6. Промпт для генерации изображения, если пост с изображением\n\nОтвет должен быть в формате JSON, содержащем массив постов, где каждый пост имеет следующие поля:\n- title: заголовок поста\n- content: HTML отформатированный текст поста\n- contentType: тип контента (один из: text, text-image, video, video-text)\n- scheduledAt: дата публикации (формат ISO)\n- hashtags: массив хештегов\n- keywords: массив ключевых слов\n- prompt: промпт для генерации изображения (только для постов с изображениями)\n\nАдаптируй контент под указанный тип, используй информацию из трендов и ключевых слов, чтобы сделать посты релевантными и интересными для целевой аудитории.`;\n\nreturn {\n  prompt,\n  campaignId,\n  userId,\n  settings,\n  directusToken,\n  dates\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        220,
        0
      ],
      "id": "9e9df976-1cac-4bd7-b69c-f005af5fe591",
      "name": "Code"
    },
    {
      "parameters": {
        "method": "POST",
        "url": "https://api.deepseek.com/v1/chat/completions",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Authorization",
              "value": "Bearer sk-7debde066de4456bbf2b029beb789db3"
            }
          ]
        },
        "sendBody": true,
        "specifyBody": "json",
        "jsonBody": "{\n  \"model\": \"deepseek-chat\",\n  \"messages\": [\n    {\n      \"role\": \"system\",\n      \"content\": \"Ты - эксперт по SMM-стратегии и контент-маркетингу для российской аудитории. Ты создаешь детальные контент-планы для бизнеса в социальных сетях.\"\n    },\n    {\n      \"role\": \"user\",\n      \"content\": \"{{$node[\"Function\"].json[\"prompt\"]}}\"\n    }\n  ],\n  \"temperature\": 0.7,\n  \"max_tokens\": 4000\n}",
        "options": {}
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 4.2,
      "position": [
        440,
        0
      ],
      "id": "1343fa9e-e8dc-4411-aa43-f9201555a819",
      "name": "HTTP Request"
    },
    {
      "parameters": {
        "jsCode": "const response = $input.first();\nconst llmResponse = response.choices[0].message.content;\nconst originalData = $node[\"Function\"].json;\n\nlet contentPlan;\ntry {\n  // Пытаемся извлечь JSON из ответа\n  const jsonMatch = llmResponse.match(/```json([\\s\\S]*?)```/) || llmResponse.match(/({[\\s\\S]*})/);\n  const jsonText = jsonMatch ? jsonMatch[1].trim() : llmResponse;\n  \n  // Парсим JSON\n  contentPlan = JSON.parse(jsonText);\n  \n  // Если это не массив, но имеет поле \"posts\", используем его\n  if (!Array.isArray(contentPlan) && contentPlan.posts && Array.isArray(contentPlan.posts)) {\n    contentPlan = contentPlan.posts;\n  }\n  \n  // Если это все еще не массив, создаем ошибку\n  if (!Array.isArray(contentPlan)) {\n    throw new Error(\"Ответ не является массивом постов\");\n  }\n\n  // Постобработка контент-плана (убедимся, что все поля присутствуют)\n  contentPlan = contentPlan.map((post, index) => {\n    // Проверяем и устанавливаем правильные типы контента\n    let contentType = post.contentType || \"text\";\n    if (![\"text\", \"text-image\", \"image-text\", \"video\", \"video-text\"].includes(contentType)) {\n      contentType = \"text\";\n    }\n    \n    // Генерируем промт для изображения если нет\n    let prompt = post.prompt || \"\";\n    if ((contentType === \"text-image\" || contentType === \"image-text\") && !prompt) {\n      prompt = `Изображение для поста \"${post.title}\". ${post.content.substring(0, 100)}`;\n    }\n\n    // Устанавливаем дату публикации\n    const scheduledAt = post.scheduledAt || originalData.dates[index]?.toISOString() || new Date().toISOString();\n    \n    // Хештеги\n    let hashtags = [];\n    if (post.hashtags) {\n      if (Array.isArray(post.hashtags)) {\n        hashtags = post.hashtags.map(h => h.startsWith('#') ? h : `#${h}`);\n      } else if (typeof post.hashtags === 'string') {\n        hashtags = post.hashtags.split(/[,\\s]+/).filter(Boolean).map(h => h.startsWith('#') ? h : `#${h}`);\n      }\n    }\n    \n    // Ключевые слова\n    let keywords = [];\n    if (post.keywords) {\n      if (Array.isArray(post.keywords)) {\n        keywords = post.keywords;\n      } else if (typeof post.keywords === 'string') {\n        keywords = post.keywords.split(/[,\\s]+/).filter(Boolean);\n      }\n    }\n\n    return {\n      title: post.title || `Пост ${index + 1}`,\n      content: post.content || \"\",\n      contentType,\n      scheduledAt,\n      hashtags,\n      keywords,\n      prompt\n    };\n  });\n\n} catch (error) {\n  // В случае ошибки пытаемся восстановить структуру из текста\n  console.log(\"Ошибка при парсинге JSON:\", error.message);\n  console.log(\"Пытаемся восстановить из текста...\");\n  \n  try {\n    // Поиск паттернов в тексте, которые могут указывать на записи\n    contentPlan = [];\n    const postSections = llmResponse.split(/Пост \\d+:|План на день \\d+:/g).filter(Boolean);\n    \n    for (let i = 0; i < postSections.length; i++) {\n      const section = postSections[i].trim();\n      const titleMatch = section.match(/Заголовок:?\\s*([^\\n]+)/i);\n      const contentMatch = section.match(/Текст[^:]*:?\\s*([\\s\\S]*?)(?=Тип контента|Хештеги|Ключевые слова|$)/i);\n      const contentTypeMatch = section.match(/Тип контента:?\\s*([^\\n]+)/i);\n      const hashtagsMatch = section.match(/Хештеги:?\\s*([\\s\\S]*?)(?=Ключевые слова|Промпт|$)/i);\n      const keywordsMatch = section.match(/Ключевые слова:?\\s*([\\s\\S]*?)(?=Промпт|$)/i);\n      const promptMatch = section.match(/Промпт:?\\s*([\\s\\S]*?)(?=$)/i);\n      \n      if (titleMatch) {\n        const post = {\n          title: titleMatch[1].trim(),\n          content: contentMatch ? contentMatch[1].trim() : \"\",\n          contentType: contentTypeMatch ? contentTypeMatch[1].trim().toLowerCase() : \"text\",\n          scheduledAt: originalData.dates[i] ? originalData.dates[i].toISOString() : new Date().toISOString(),\n          hashtags: hashtagsMatch ? hashtagsMatch[1].split(/[,\\s#]+/).filter(Boolean).map(h => h.startsWith('#') ? h : `#${h}`) : [],\n          keywords: keywordsMatch ? keywordsMatch[1].split(/[,\\s]+/).filter(Boolean) : [],\n          prompt: promptMatch ? promptMatch[1].trim() : \"\"\n        };\n        contentPlan.push(post);\n      }\n    }\n    \n    if (contentPlan.length === 0) {\n      throw new Error(\"Не удалось восстановить структуру постов из текста\");\n    }\n  } catch (recoveryError) {\n    console.log(\"Не удалось восстановить структуру из текста:\", recoveryError.message);\n    return {\n      success: false,\n      error: \"Ошибка при обработке ответа от LLM\",\n      message: \"Не удалось получить корректный формат контент-плана\",\n      rawResponse: llmResponse.substring(0, 1000) + \"...\" // Обрезаем длинный ответ\n    };\n  }\n}\n\nreturn {\n  success: true,\n  data: {\n    contentPlan,\n    campaignId: originalData.campaignId\n  }\n};"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [
        660,
        0
      ],
      "id": "5965c6ce-02b0-4ed1-871f-214032a52d80",
      "name": "Code1"
    }
  ],
  "connections": {
    "Webhook": {
      "main": [
        [
          {
            "node": "Code",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Code": {
      "main": [
        [
          {
            "node": "HTTP Request",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "HTTP Request": {
      "main": [
        [
          {
            "node": "Code1",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "pinData": {},
  "meta": {
    "instanceId": "d69b135e70f406a0ace9f751f1d688634763e75d1dec57b0a74654d8144965c4"
  }
}