# Текущая логика публикации

## 1. Инициализация

### Где запускается процесс?
- **Основной роут**: `/api/publish/:contentId` (POST) в `server/api/publishing-routes.ts:353`
- **Тестовый роут**: `/api/publish/content` (POST) в `server/api/publishing-routes.ts:172`
- **Планировщик**: `publishScheduler.checkScheduledContent()` в `server/services/publish-scheduler.ts`
- **Принудительная проверка**: `/api/publish/check-scheduled` (ALL)

### Какие параметры обязательны?
- `contentId` - ID контента для публикации
- `platforms` - массив или объект платформ для публикации (например: `["telegram", "vk"]` или `{telegram: true, vk: false}`)
- Системный токен авторизации (получается автоматически)

## 2. Платформы

### Как определяется список платформ для публикации?
- **Из параметра запроса**: поле `platforms` в теле POST запроса
- **Из базы данных**: поле `social_platforms` в таблице `campaign_content`
- **Логика выбора**: если платформа присутствует в JSON `social_platforms`, она считается выбранной
- **Поддерживаемые платформы**: telegram, vk, instagram, facebook

### Где хранятся credentials?
- **Настройки кампании**: `campaign.socialMediaSettings` в таблице `user_campaigns`
- **Структура для Telegram**: `{telegram: {token: "bot_token", chatId: "chat_id"}}`
- **Структура для VK**: `{vk: {token: "access_token", groupId: "group_id"}}`
- **Структура для Instagram**: `{instagram: {token: "access_token", profileId: "profile_id"}}`
- **Кэширование**: настройки кэшируются на 15 минут в `campaignSettingsCache`

## 3. Процесс постинга

### Последовательность вызовов API
1. **Получение контента**: `storage.getCampaignContentById(contentId)`
2. **Получение кампании**: `storage.getCampaignById(content.campaignId)`
3. **Получение системного токена**: `socialPublishingService.getSystemToken()`
4. **Обновление статуса на pending**: `storage.updateCampaignContent()` с `status: 'pending'`
5. **Публикация на каждую платформу**: 
   - **Facebook**: прямая публикация через `socialPublishingService.publishToPlatform()`
   - **Остальные платформы**: вызов n8n воркфлоу через `publishViaN8nAsync()`
6. **Обновление статуса результата**: обновление `social_platforms` с результатом публикации

### N8n воркфлоу адреса
- **Telegram**: `https://n8n.nplanner.ru/webhook/publish-telegram`
- **VK**: `https://n8n.nplanner.ru/webhook/publish-vk` 
- **Instagram**: `https://n8n.nplanner.ru/webhook/publish-instagram`
- **Facebook**: обрабатывается напрямую без n8n

### Как обрабатываются ошибки?
- **При ошибке на платформе**: статус устанавливается в `'failed'`, сохраняется текст ошибки
- **При частичном успехе**: успешные платформы получают статус `'published'`, неудачные - `'failed'`
- **При полном провале**: возвращается HTTP 500 с деталями ошибок

## 4. Статусы

### Когда и как обновляются статусы платформ?
- **Перед публикацией**: все выбранные платформы получают статус `'pending'`
- **После успешной публикации**: платформа получает:
  - `status: 'published'`
  - `postUrl: <URL_поста>` 
  - `postId: <ID_поста>`
  - `publishedAt: new Date()`
- **После ошибки**: платформа получает:
  - `status: 'failed'`
  - `error: <текст_ошибки>`

### Критерии для статуса "published" контента
- **ВСЕ выбранные платформы** должны иметь статус `'published'` И `postUrl`
- Проверка выполняется в `publishScheduler.checkScheduledContent()` каждые 20 секунд
- Обновление происходит автоматически через планировщик

## 5. Проблемные места

### Где возможны дублирования?
1. **Повторные вызовы API публикации** - нет блокировки на уровне роутов
2. **Планировщик + ручная публикация** - могут выполняться параллельно
3. **Отсутствие проверки уже опубликованного контента** в основных роутах
4. **Кэш `processedContentIds`** больше не используется (deprecated)

### Где нет проверки postUrl?
1. **В роуте `/api/publish/:contentId`** - не проверяется наличие `postUrl` перед публикацией
2. **В роуте `/api/publish/content`** - аналогично отсутствует проверка
3. **Только планировщик** имеет проверку: `if (platformData.postUrl && platformData.postUrl.trim() !== '')`

### Механизм обновления статусов через n8n
- **После вызова n8n**: автоматический POST на `/api/publish/update-status` с `contentId`
- **Обновление статуса**: n8n воркфлоу сам обновляет `social_platforms` после публикации
- **Асинхронность**: статус обновляется отдельно от основного запроса публикации

### Критические проблемы:
1. **Дублирование публикаций**: роуты публикации не проверяют `postUrl` перед публикацией
2. **Параллельное выполнение**: планировщик и API могут публиковать одновременно
3. **Неконсистентность статусов**: статус может быть `'published'` без `postUrl`
4. **Отсутствие блокировок**: нет механизма предотвращения повторных публикаций
5. **Асинхронная гонка**: n8n может обновить статус после повторного вызова API
6. **Двойной вызов n8n**: API не проверяет статусы платформ перед отправкой в n8n

### Логи и мониторинг:
- Все операции логируются через `log()` функцию
- Детальное логирование в режиме `verboseLogging`
- Ошибки публикации сохраняются в поле `error` платформы
- Планировщик выводит статистику каждые 20 секунд